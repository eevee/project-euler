#!/usr/bin/env perl

package Brainfuck::VM;

use strict;
use warnings;

use Term::ReadKey;

=head1 NAME

Brainfuck::VM -- virtual brainfuck machine

=head1 DESCRIPTION

Runs a Brainfuck program.  That's all.

=cut 

use base 'Class::Accessor::Fast';
__PACKAGE__->mk_accessors(qw/ tape tape_cursor ops op_cursor loop_stack /);

=head1 ATTRIBUTES

This class inherits from L<Class::Accessor::Fast>, so its attributes are
methods generated by C<mk_accessors>.

=head2 tape

Arrayref, representing the tape.  The tape has no artificial limits on either
its length or its contents.

=head2 tape_cursor

Index of the current position in the tape.

=head2 ops

Arrayref of instructions seen so far.  As new instructions are read, they are
appended to this arrayref.

=head2 op_cursor

Index of the next instruction to execute.  If this points past the end of the
C<ops> array, the next instruction will be read from the source.  The program
will end if there are no more instructions.

=head2 loop_stack

A stack of indices into the C<ops> array, corresponding to any loop-start
instructions that have not yet been canceled by a matching loop-end.

=cut

my %operations = (
    '>' => 'next',
    '<' => 'prev',
    '+' => 'inc',
    '-' => 'dec',
    '[' => 'loop_start',
    ']' => 'loop_end',
    ',' => 'read',
    '.' => 'write',
);

# Set to 1 for debugging information
our $DEBUG = 0;
our $DEBUG_MAX_CELLS = 10;

=head1 METHODS

=head2 new

Creates a new VM.

=cut

sub new {
    my ($class) = @_;
    my $self = {};
    bless $self, $class;

    $self->reset;
    return $self;
}

=head2 reset

Clears the state of the VM.

=cut

sub reset {
    my ($self) = @_;

    $self->tape([0]);
    $self->tape_cursor(0);
    $self->ops([]);
    $self->op_cursor(0);

    $self->loop_stack([]);

    return;
}

=head2 load($str)

Loads the code found in the given string.

=cut

sub load {
    my ($self, $str) = @_;

    # Store list of operators
    # Need ][ first for the char class to be valid
    my @valid_ops = sort {
           ($a eq ']') * -1 || ($b eq ']') * 1
        || ($a eq '[') * -1 || ($b eq '[') * 1
        || $a cmp $b
    } keys %operations;
    my $valid_ops = join '', @valid_ops;
    $str =~ s/[^$valid_ops]//g;

    if ($DEBUG) {
        print STDERR $str, "\n";
    }

    my @methods = grep { defined } map { $operations{$_} } split //, $str;
    $self->ops(\@methods);

    return;
}

=head2 optimized_ops

Returns an array of "optimized" instructions, useful for compiling to a
higher-level intermediate language more efficiently.  Currently, the only
optimization done is to collapse identical adjacent instructions into one
item.

Every element returned is of the form C<[ $method, $count ]>.

=cut

sub optimized_ops {
    my ($self) = @_;

    my @ops = @{ $self->ops };
    my @ret;

    while (my $op = shift @ops) {
        my $ct = 1;
        while (@ops and $ops[0] eq $op) {
            # Dupe!
            $ct++;
            shift @ops;
        }
        push @ret, [ $op => $ct ];
    }

    return @ret;
}

=head2 compile

Compiles the current code to Perl and C<eval>s it.  This is several orders of
magnitude faster, but debug mode is not supported.

=cut

sub compile {
    my ($self) = @_;

    # Unbuffer i/o, since it's one byte at a time
    local $| = 0;
    ReadMode 'cbreak';

    my $perl = '';

    my %fragments = (
        inc         => sub { '$tape->[$pos] += ' . $_[0] . ';' },
        dec         => sub { '$tape->[$pos] -= ' . $_[0] . ';' },
        next        => sub { '$pos += ' . $_[0] . ';' },
        prev        => sub { '$pos -= ' . $_[0] . ';' },
        loop_start  => ' while ($tape->[$pos]) { ',
        loop_end    => ' } ',
        read        => ' $tape->[$pos] = ord ReadKey 0; ',
        write       => ' print chr $tape->[$pos]; ',
    );

    # Vars used inside the above fragments
    my $pos  = $self->tape_cursor;
    my $tape = $self->tape;

    # Dumb optimizations
    my @merged_ops = $self->optimized_ops;

    # Dumbly compile operators to Perl code
    for my $ref (@merged_ops) {
        my ($op, $ct) = @{$ref};
        my $fragment = $fragments{$op};

        if (ref $fragment eq 'CODE') {
            $perl .= $fragment->($ct);
        }
        else {
            $perl .= $fragment x $ct;
        }
        $perl .= "\n";
    }

    # Run it
    eval { eval $perl };

    $self->tape_cursor($pos);

    ReadMode 1;
}

=head2 compile_to_c

Returns the current code as executable C source code.

=cut

sub compile_to_c {
    my ($self) = @_;

    my $c = "#include <stdio.h>\n";
    $c   .= "int main() {\n";
    $c   .= "    unsigned int ary[32768];\n";
    $c   .= "    int i;\n";
    $c   .= "    for (i = 0; i < 32768; i++) ary[i] = 0;\n";
    $c   .= "    unsigned int *ptr = ary;\n";

    my %fragments = (
        inc         => sub { '*ptr += ' . $_[0] . ';' },
        dec         => sub { '*ptr -= ' . $_[0] . ';' },
        next        => sub { 'ptr += ' . $_[0] . ';' },
        prev        => sub { 'ptr -= ' . $_[0] . ';' },
        loop_start  => ' while (*ptr) { ',
        loop_end    => ' } ',
        read        => ' *ptr = getchar(); ',
        write       => ' printf("%c", *ptr); ',
    );

    my @merged_ops = $self->optimized_ops;

    for my $ref (@merged_ops) {
        my ($op, $ct) = @{$ref};
        my $fragment = $fragments{$op};

        $c .= '    ';
        if (ref $fragment eq 'CODE') {
            $c .= $fragment->($ct);
        }
        else {
            $c .= $fragment x $ct;
        }
        $c .= "\n";
    }

    $c .= "    return 0;\n";
    $c .= "}\n";

    return $c;
}

=head2 execute

Executes the current code.

=cut

sub execute {
    my ($self) = @_;

    # Unbuffer i/o, since it's one byte at a time
    local $| = 0;
    ReadMode 'cbreak';

    while (1) {
        # Loop continuously, executing the operation under the cursor and
        # advancing it one position.

        my $method = $self->get_next_op
            or last;

        $self->$method;

        if ($DEBUG) {
            print STDERR '  ' x @{ $self->loop_stack };
            printf STDERR "%4d: %10s", $self->op_cursor, $method;
            print STDERR '  ' x (10 - @{ $self->loop_stack });
            for my $i (0 .. $#{ $self->tape }) {
                last if $i >= $DEBUG_MAX_CELLS;
                printf STDERR "%5d%1s",
                    $self->tape->[$i],
                    $i == $self->tape_cursor ? '*' : '',
                    ;
            }
            if ($self->tape_cursor >= $DEBUG_MAX_CELLS) {
                printf STDERR "  [%4d:%4d]", $self->tape_cursor, $self->value;
            }
            print "\n";
        }
    }

    ReadMode 1;
}

=head2 get_next_op

Returns a method reference corresponding to the next instruction to execute,
or undef if there are no more.  Also increments the op cursor.

=cut

sub get_next_op {
    my ($self) = @_;
    my ($op, $method);
    while (1) {
        $op = $self->ops->[ $self->op_cursor ];
        return if not $op;

        $self->op_cursor( $self->op_cursor + 1 );
        return $op;
    }
}

=head2 value([$new_value])

Fake accessor for setting the current value.

=cut

sub value {
    my ($self, $new_value) = @_;

    if (defined $new_value) {
        $self->tape->[ $self->tape_cursor ] = $new_value;
    }

    return $self->tape->[ $self->tape_cursor ];
}

=head2 next

Increments the tape cursor.

=cut

sub next {
    my ($self) = @_;
    $self->tape_cursor($self->tape_cursor + 1);

    # Prefill cell if necessary
    $self->tape->[$self->tape_cursor] ||= 0;
    return;
}

=head2 prev

Decrements the tape cursor.

=cut

sub prev {
    my ($self) = @_;

    # [DESIGN] < when on the first cell is a no-op
    if ($self->tape_cursor == 0) {
        if ($DEBUG) {
            warn "TRYING TO GO LEFT PAST THE START OF THE TAPE";
        }
        return;
    }

    $self->tape_cursor($self->tape_cursor - 1);
    return;
}

=head2 inc

Increments the value in the current cell.

=cut

sub inc {
    my ($self) = @_;
    $self->value( $self->value + 1 );
    return;
}

=head2 dec

Decrements the value in the current cell.

=cut

sub dec {
    my ($self) = @_;
    $self->value( $self->value - 1 );
    return;
}

=head2 read

Reads a single byte from STDIN and stores its ASCII value in the current cell.

=cut

sub read {
    my ($self) = @_;
    my $chr;
    $chr = ReadKey 0;
    $self->value( ord $chr );
    return;
}

=head2 write

Prints the value in the current cell to STDOUT as ASCII.

=cut

sub write {
    my ($self) = @_;
    print chr $self->value;
    return;
}

=head2 loop_start

Begins a loop.

If the current cell's value is zero, skips to its matching loop_end.

=cut

sub loop_start {
    my ($self) = @_;

    if ($self->value != 0) {
        push @{$self->loop_stack}, $self->op_cursor;
        return;
    }

    my $next_op;
    my $inner_loops;
    while (1) {
        $next_op = $self->get_next_op;
#print "$next_op...";
        return if not $next_op;

        if ($next_op eq 'loop_start') {
            $inner_loops++;
        }
        elsif ($next_op eq 'loop_end') {
            if ($inner_loops) {
                $inner_loops--;
            }
            else {
                last;
            }
        }
    }

    return;
}

=head2 loop_end

If the value in the current cell is nonzero, moves the instruction cursor back
to the position at the top of the C<loop_stack>.  Otherwise, pops the top
value off of the C<loop_stack>.

=cut

sub loop_end {
    my ($self) = @_;

    if ($self->value == 0) {
        # Break
        pop @{$self->loop_stack};
    }
    else {
        # Rewind to matching [
#        warn "REWINDING TO: ", join ' ; ', @{$self->loop_stack};
        $self->op_cursor( $self->loop_stack->[-1] );
    }
    return;
}

=head1 AUTHOR

Eevee

=cut


package main;

use strict;
use warnings;

use File::Slurp qw(read_file);

#local $Brainfuck::VM::DEBUG = 1;

for my $file (@ARGV) {
    my $code = read_file($file);
    my $bf = Brainfuck::VM->new;
    $bf->load($code);
    #$bf->execute;
    $bf->compile;
    #print $bf->compile_to_c;
}

